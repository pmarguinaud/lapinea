PROGRAM WRAP_LAPINEA

USE LOAD_GEOMETRY_MOD
USE LOAD_SL_STRUCT_MOD
USE LOAD_MODEL_GENERAL_CONF_TYPE_MOD
USE LOAD_MODEL_DYNAMICS_TYPE_MOD

USE COPY_GEOMETRY_MOD
USE COPY_SL_STRUCT_MOD
USE COPY_MODEL_GENERAL_CONF_TYPE_MOD
USE COPY_MODEL_DYNAMICS_TYPE_MOD

USE LOAD_MOD
#ifdef USE_ACC
USE CUDAFOR
#endif

USE LOAD_YOMCT0_MOD
USE LOAD_YOMDYNA_MOD
USE LOAD_YOMCVER_MOD
USE LOAD_YOMCST_MOD
USE LOAD_YOMMP0_MOD
USE LOAD_YOMLUN_MOD
USE LOAD_YOMJFH_MOD

USE XRD_GETOPTIONS

USE PARKIND1

IMPLICIT NONE

INTERFACE CPRS
  PROCEDURE CPRSX1, CPRSX2, CPRSX3, CPRSI1, CPRSI3
END INTERFACE

INTERFACE REALO
  PROCEDURE REALOX1, REALOX2, REALOX3, REALOI1, REALOI3
END INTERFACE

TYPE (GEOMETRY)                :: YDGEOMETRY
TYPE (MODEL_GENERAL_CONF_TYPE) :: YDML_GCONF
TYPE (MODEL_DYNAMICS_TYPE)     :: YDML_DYN
TYPE (SL_STRUCT)               :: YDSL

REAL (KIND=JPRB)   , POINTER :: PB1     (:,:)
REAL (KIND=JPRB)   , POINTER :: PB2     (:,:,:)

INTEGER (KIND=JPIM), POINTER :: KVSEPC  (:)
INTEGER (KIND=JPIM), POINTER :: KVSEPL  (:)
REAL (KIND=JPRB)   , POINTER :: PCCO    (:,:,:,:)
REAL (KIND=JPRB)   , POINTER :: PUF     (:,:,:)
REAL (KIND=JPRB)   , POINTER :: PVF     (:,:,:)
INTEGER (KIND=JPIM), POINTER :: KL0     (:,:,:,:)
INTEGER (KIND=JPIM), POINTER :: KLH0    (:,:,:,:)
REAL (KIND=JPRB)   , POINTER :: PLSCAW  (:,:,:,:)
REAL (KIND=JPRB)   , POINTER :: PRSCAW  (:,:,:,:)
INTEGER (KIND=JPIM), POINTER :: KL0H    (:,:,:,:)
REAL (KIND=JPRB)   , POINTER :: PLSCAWH (:,:,:,:)
REAL (KIND=JPRB)   , POINTER :: PRSCAWH (:,:,:,:)
REAL (KIND=JPRB)   , POINTER :: PSCO    (:,:,:,:)
REAL (KIND=JPRB)   , POINTER :: PGFLT1  (:,:,:,:)

#include "lapinea.intfb.h"

INTEGER (KIND=JPIM), POINTER :: KVSEPC_OUT  (:)
INTEGER (KIND=JPIM), POINTER :: KVSEPL_OUT  (:)
REAL (KIND=JPRB)   , POINTER :: PCCO_OUT    (:,:,:,:)
REAL (KIND=JPRB)   , POINTER :: PUF_OUT     (:,:,:)
REAL (KIND=JPRB)   , POINTER :: PVF_OUT     (:,:,:)
INTEGER (KIND=JPIM), POINTER :: KL0_OUT     (:,:,:,:)
INTEGER (KIND=JPIM), POINTER :: KLH0_OUT    (:,:,:,:)
REAL (KIND=JPRB)   , POINTER :: PLSCAW_OUT  (:,:,:,:)
REAL (KIND=JPRB)   , POINTER :: PRSCAW_OUT  (:,:,:,:)
INTEGER (KIND=JPIM), POINTER :: KL0H_OUT    (:,:,:,:)
REAL (KIND=JPRB)   , POINTER :: PLSCAWH_OUT (:,:,:,:)
REAL (KIND=JPRB)   , POINTER :: PRSCAWH_OUT (:,:,:,:)
REAL (KIND=JPRB)   , POINTER :: PSCO_OUT    (:,:,:,:)
REAL (KIND=JPRB)   , POINTER :: PGFLT1_OUT  (:,:,:,:)

INTEGER :: IDUM, ILUN
INTEGER :: NGPBLKS, NPROMA, NFLEVG
INTEGER :: IST,IEND,IBL,JLON


CHARACTER (LEN=64) :: CLFILE, CLCASE
LOGICAL :: LLDIFF
INTEGER :: ICOUNT, NTIMES, ITIME
INTEGER, POINTER :: IDIFFBLOCK (:) => NULL ()
INTEGER (KIND=8) :: HEAPSIZE
INTEGER (KIND=4) :: HEAPSIZE4
INTEGER (KIND=4) :: ISTAT
LOGICAL :: LLSINGLEBLOCK


CALL INITOPTIONS ()
CALL GETOPTION ("--case", CLCASE, MND = .TRUE.)
CALL GETOPTION ("--diff", LLDIFF)
CALL GETOPTION ("--diff-block-list", IDIFFBLOCK)
ICOUNT = 0
CALL GETOPTION ("--count", ICOUNT)
HEAPSIZE4 = 0
CALL GETOPTION ("--heapsize", HEAPSIZE4)
NTIMES = 1
CALL GETOPTION ("--times", NTIMES)
CALL GETOPTION ("--single-block", LLSINGLEBLOCK)
CALL CHECKOPTIONS ()

#ifdef USE_ACC
IF (HEAPSIZE4 > 0) THEN
HEAPSIZE = HEAPSIZE4*1024_8*1024_8
ISTAT = CUDADEVICESETLIMIT (CUDALIMITMALLOCHEAPSIZE, HEAPSIZE)
ENDIF

CALL CUDAPROFILERSTOP
#endif

ILUN = 77

#define LOADM(x) CALL O (#x); CALL LOAD_##x (ILUN); CLOSE (ILUN); IDUM

LOADM (YOMCT0) = 0
LOADM (YOMDYNA) = 0
LOADM (YOMCVER) = 0
LOADM (YOMCST) = 0
LOADM (YOMMP0) = 0
LOADM (YOMLUN) = 0
LOADM (YOMJFH) = 0

#undef LOADM

#define LOAD(x) CALL O (#x//".IN"); CALL LOAD (ILUN, x); CLOSE (ILUN); IDUM

LOAD (YDGEOMETRY) = 0 
LOAD (YDML_GCONF) = 0
LOAD (YDSL) = 0
LOAD (YDML_DYN) = 0
LOAD (PB1) = 0
LOAD (PB2) = 0
LOAD (KVSEPC) = 0
LOAD (KVSEPL) = 0
LOAD (PCCO) = 0
LOAD (PUF) = 0
LOAD (PVF) = 0
LOAD (KL0) = 0
LOAD (KLH0) = 0
LOAD (PLSCAW) = 0
LOAD (PRSCAW) = 0
LOAD (KL0H) = 0
LOAD (PLSCAWH) = 0
LOAD (PRSCAWH) = 0
LOAD (PSCO) = 0
LOAD (PGFLT1) = 0


!$acc enter data create (YDGEOMETRY) 
CALL COPY (YDGEOMETRY) 
!$acc enter data create (YDML_GCONF) 
CALL COPY (YDML_GCONF)
!$acc enter data create (YDSL) 
CALL COPY (YDSL) 
!$acc enter data create (YDML_DYN) 
CALL COPY (YDML_DYN) 

IF (ICOUNT == 0) ICOUNT = SIZE (KVSEPC)

NGPBLKS = MIN (SIZE (KVSEPC), ICOUNT)
NPROMA = YDGEOMETRY%YRDIM%NPROMA
NFLEVG = YDGEOMETRY%YRDIMV%NFLEVG

#undef LOAD

#ifdef USE_ACC
CALL CUDAPROFILERSTART 
#endif

DO ITIME = 1, NTIMES

!$acc parallel loop gang vector private (IBL, JLON, IST, IEND) collapse (2) vector_length (NPROMA) &
!$acc & present (YDGEOMETRY, YDML_GCONF, YDSL, YDML_DYN) copyin (PB1, PB2) &
!$acc & copy (KVSEPC, KVSEPL) &
!$acc & copyout (PCCO, PUF, PVF, KL0, KLH0, PLSCAW, PRSCAW, KL0H, PLSCAWH, PRSCAWH, PSCO,PGFLT1)

  DO IBL = 1, NGPBLKS
   
    DO JLON = 1, NPROMA
    IST=JLON
    IEND=JLON

    CALL LAPINEA(&
     ! --- INPUT --------------------------------------------------------------
     & YDGEOMETRY,YDML_GCONF,YDML_DYN,IST,IEND,YDSL,IBL,PB1,PB2(:,:,IBL),&
     ! --- INPUT/OUTPUT -------------------------------------------------------
     & KVSEPC(IBL),KVSEPL(IBL),&
     ! --- OUTPUT -------------------------------------------------------------
     & PCCO(:,:,:,IBL),PUF(:,:,IBL),PVF(:,:,IBL),&
     & KL0(:,:,:,IBL),KLH0(:,:,:,IBL),PLSCAW(:,:,:,IBL),PRSCAW(:,:,:,IBL),&
     & KL0H(:,:,:,IBL),PLSCAWH(:,:,:,IBL),PRSCAWH(:,:,:,IBL),&
     & PSCO(:,:,:,IBL),PGFLT1(:,:,:,IBL))
    ENDDO

  ENDDO

!$acc end parallel loop 

ENDDO

#ifdef USE_ACC
CALL CUDAPROFILERSTOP
#endif


IF (LLDIFF) THEN

#define LOAD(x) CALL O (#x//".OUT"); CALL LOAD (ILUN, x##_OUT); CLOSE (ILUN); IDUM

LOAD (KVSEPC) = 0
LOAD (KVSEPL) = 0
LOAD (PCCO) = 0
LOAD (PUF) = 0
LOAD (PVF) = 0
LOAD (KL0) = 0
LOAD (KLH0) = 0
LOAD (PLSCAW) = 0
LOAD (PRSCAW) = 0
LOAD (KL0H) = 0
LOAD (PLSCAWH) = 0
LOAD (PRSCAWH) = 0
LOAD (PSCO) = 0
LOAD (PGFLT1) = 0

PRINT *, " DIFF "

DO IBL = 1, NGPBLKS

  IF (ASSOCIATED (IDIFFBLOCK)) THEN
    IF (ALL (IDIFFBLOCK /= IBL)) CYCLE
  ENDIF

  PRINT *, " IBLOCK = ", IBL

  CALL DIFF ("KVSEPC", KVSEPC_OUT (IBL), KVSEPC (IBL))
  CALL DIFF ("KVSEPL", KVSEPL_OUT (IBL), KVSEPL (IBL))
  CALL DIFF ("PCCO", PCCO_OUT (:,:,:,IBL), PCCO (:,:,:,IBL))
ENDDO


ENDIF


CONTAINS

SUBROUTINE O (CDFILE)

INTEGER, PARAMETER :: MYPROC = 1

CHARACTER (LEN=*) :: CDFILE

WRITE (CLFILE, '(I3.3)') MYPROC
CLFILE=TRIM (CDFILE)//"."//TRIM (CLFILE)

OPEN (ILUN, FILE=TRIM (CLCASE)//"/"//TRIM (CLFILE), FORM='UNFORMATTED')

END SUBROUTINE

SUBROUTINE RS_GSGEOM (X1)

USE YOMGSGEOM, ONLY : TGSGEOM

TYPE (TGSGEOM), POINTER :: X1 (:), X1_ (:)

INTEGER :: JLON, JBLK, NLON, NBLK

NBLK = SIZE (X1, 1)
NLON = SIZE (X1(1)%RCORI, 1)

ALLOCATE (X1_ (1))

IF (ASSOCIATED (X1 (1)%RCORI    )) ALLOCATE (X1_ (1)%RCORI       (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%RCORIC   )) ALLOCATE (X1_ (1)%RCORIC      (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%GEMU     )) ALLOCATE (X1_ (1)%GEMU        (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%GSQM2    )) ALLOCATE (X1_ (1)%GSQM2       (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%GELAM    )) ALLOCATE (X1_ (1)%GELAM       (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%GELAT    )) ALLOCATE (X1_ (1)%GELAT       (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%GECLO    )) ALLOCATE (X1_ (1)%GECLO       (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%GESLO    )) ALLOCATE (X1_ (1)%GESLO       (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%GM       )) ALLOCATE (X1_ (1)%GM          (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%GMAPPA   )) ALLOCATE (X1_ (1)%GMAPPA      (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%GOMVRL   )) ALLOCATE (X1_ (1)%GOMVRL      (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%GOMVRM   )) ALLOCATE (X1_ (1)%GOMVRM      (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%GNORDL   )) ALLOCATE (X1_ (1)%GNORDL      (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%GNORDM   )) ALLOCATE (X1_ (1)%GNORDM      (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%GNORDLCL )) ALLOCATE (X1_ (1)%GNORDLCL    (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%GNORDMCL )) ALLOCATE (X1_ (1)%GNORDMCL    (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%GNORDMCM )) ALLOCATE (X1_ (1)%GNORDMCM    (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%GAW      )) ALLOCATE (X1_ (1)%GAW         (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%NGPLAT   )) ALLOCATE (X1_ (1)%NGPLAT      (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%NUNIQUEGP)) ALLOCATE (X1_ (1)%NUNIQUEGP   (NBLK*NLON))

DO JBLK = 1, NBLK
  DO JLON = 1, SIZE (X1(JBLK)%RCORI, 1)
    IF (ASSOCIATED (X1_ (1)%RCORI    )) X1_ (1)%RCORI       ((JBLK-1)*NLON+JLON) = X1 (JBLK)%RCORI     (JLON)
    IF (ASSOCIATED (X1_ (1)%RCORIC   )) X1_ (1)%RCORIC      ((JBLK-1)*NLON+JLON) = X1 (JBLK)%RCORIC    (JLON)
    IF (ASSOCIATED (X1_ (1)%GEMU     )) X1_ (1)%GEMU        ((JBLK-1)*NLON+JLON) = X1 (JBLK)%GEMU      (JLON)
    IF (ASSOCIATED (X1_ (1)%GSQM2    )) X1_ (1)%GSQM2       ((JBLK-1)*NLON+JLON) = X1 (JBLK)%GSQM2     (JLON)
    IF (ASSOCIATED (X1_ (1)%GELAM    )) X1_ (1)%GELAM       ((JBLK-1)*NLON+JLON) = X1 (JBLK)%GELAM     (JLON)
    IF (ASSOCIATED (X1_ (1)%GELAT    )) X1_ (1)%GELAT       ((JBLK-1)*NLON+JLON) = X1 (JBLK)%GELAT     (JLON)
    IF (ASSOCIATED (X1_ (1)%GECLO    )) X1_ (1)%GECLO       ((JBLK-1)*NLON+JLON) = X1 (JBLK)%GECLO     (JLON)
    IF (ASSOCIATED (X1_ (1)%GESLO    )) X1_ (1)%GESLO       ((JBLK-1)*NLON+JLON) = X1 (JBLK)%GESLO     (JLON)
    IF (ASSOCIATED (X1_ (1)%GM       )) X1_ (1)%GM          ((JBLK-1)*NLON+JLON) = X1 (JBLK)%GM        (JLON)
    IF (ASSOCIATED (X1_ (1)%GMAPPA   )) X1_ (1)%GMAPPA      ((JBLK-1)*NLON+JLON) = X1 (JBLK)%GMAPPA    (JLON)
    IF (ASSOCIATED (X1_ (1)%GOMVRL   )) X1_ (1)%GOMVRL      ((JBLK-1)*NLON+JLON) = X1 (JBLK)%GOMVRL    (JLON)
    IF (ASSOCIATED (X1_ (1)%GOMVRM   )) X1_ (1)%GOMVRM      ((JBLK-1)*NLON+JLON) = X1 (JBLK)%GOMVRM    (JLON)
    IF (ASSOCIATED (X1_ (1)%GNORDL   )) X1_ (1)%GNORDL      ((JBLK-1)*NLON+JLON) = X1 (JBLK)%GNORDL    (JLON)
    IF (ASSOCIATED (X1_ (1)%GNORDM   )) X1_ (1)%GNORDM      ((JBLK-1)*NLON+JLON) = X1 (JBLK)%GNORDM    (JLON)
    IF (ASSOCIATED (X1_ (1)%GNORDLCL )) X1_ (1)%GNORDLCL    ((JBLK-1)*NLON+JLON) = X1 (JBLK)%GNORDLCL  (JLON)
    IF (ASSOCIATED (X1_ (1)%GNORDMCL )) X1_ (1)%GNORDMCL    ((JBLK-1)*NLON+JLON) = X1 (JBLK)%GNORDMCL  (JLON)
    IF (ASSOCIATED (X1_ (1)%GNORDMCM )) X1_ (1)%GNORDMCM    ((JBLK-1)*NLON+JLON) = X1 (JBLK)%GNORDMCM  (JLON)
    IF (ASSOCIATED (X1_ (1)%GAW      )) X1_ (1)%GAW         ((JBLK-1)*NLON+JLON) = X1 (JBLK)%GAW       (JLON)
    IF (ASSOCIATED (X1_ (1)%NGPLAT   )) X1_ (1)%NGPLAT      ((JBLK-1)*NLON+JLON) = X1 (JBLK)%NGPLAT    (JLON)
    IF (ASSOCIATED (X1_ (1)%NUNIQUEGP)) X1_ (1)%NUNIQUEGP   ((JBLK-1)*NLON+JLON) = X1 (JBLK)%NUNIQUEGP (JLON)
  ENDDO
ENDDO

DO JBLK = 1, NBLK
 IF (ASSOCIATED (X1 (JBLK)%RCORI    )) DEALLOCATE (X1 (JBLK)%RCORI    )
 IF (ASSOCIATED (X1 (JBLK)%RCORIC   )) DEALLOCATE (X1 (JBLK)%RCORIC   )
 IF (ASSOCIATED (X1 (JBLK)%GEMU     )) DEALLOCATE (X1 (JBLK)%GEMU     )
 IF (ASSOCIATED (X1 (JBLK)%GSQM2    )) DEALLOCATE (X1 (JBLK)%GSQM2    )
 IF (ASSOCIATED (X1 (JBLK)%GELAM    )) DEALLOCATE (X1 (JBLK)%GELAM    )
 IF (ASSOCIATED (X1 (JBLK)%GELAT    )) DEALLOCATE (X1 (JBLK)%GELAT    )
 IF (ASSOCIATED (X1 (JBLK)%GECLO    )) DEALLOCATE (X1 (JBLK)%GECLO    )
 IF (ASSOCIATED (X1 (JBLK)%GESLO    )) DEALLOCATE (X1 (JBLK)%GESLO    )
 IF (ASSOCIATED (X1 (JBLK)%GM       )) DEALLOCATE (X1 (JBLK)%GM       )
 IF (ASSOCIATED (X1 (JBLK)%GMAPPA   )) DEALLOCATE (X1 (JBLK)%GMAPPA   )
 IF (ASSOCIATED (X1 (JBLK)%GOMVRL   )) DEALLOCATE (X1 (JBLK)%GOMVRL   )
 IF (ASSOCIATED (X1 (JBLK)%GOMVRM   )) DEALLOCATE (X1 (JBLK)%GOMVRM   )
 IF (ASSOCIATED (X1 (JBLK)%GNORDL   )) DEALLOCATE (X1 (JBLK)%GNORDL   )
 IF (ASSOCIATED (X1 (JBLK)%GNORDM   )) DEALLOCATE (X1 (JBLK)%GNORDM   )
 IF (ASSOCIATED (X1 (JBLK)%GNORDLCL )) DEALLOCATE (X1 (JBLK)%GNORDLCL )
 IF (ASSOCIATED (X1 (JBLK)%GNORDMCL )) DEALLOCATE (X1 (JBLK)%GNORDMCL )
 IF (ASSOCIATED (X1 (JBLK)%GNORDMCM )) DEALLOCATE (X1 (JBLK)%GNORDMCM )
 IF (ASSOCIATED (X1 (JBLK)%GAW      )) DEALLOCATE (X1 (JBLK)%GAW      )
 IF (ASSOCIATED (X1 (JBLK)%NGPLAT   )) DEALLOCATE (X1 (JBLK)%NGPLAT   )
 IF (ASSOCIATED (X1 (JBLK)%NUNIQUEGP)) DEALLOCATE (X1 (JBLK)%NUNIQUEGP)
ENDDO

DEALLOCATE (X1)

X1 => X1_

END SUBROUTINE

SUBROUTINE RS_CSGEOM (X1)

USE YOMCSGEOM, ONLY : TCSGEOM

TYPE (TCSGEOM), POINTER :: X1 (:), X1_ (:)

INTEGER :: JLON, JBLK, NLON, NBLK

NBLK = SIZE (X1, 1)
NLON = SIZE (X1(1)%RCOLON, 1)

ALLOCATE (X1_ (1))

IF (ASSOCIATED (X1 (1)%RCOLON  )) ALLOCATE (X1_ (1)%RCOLON     (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%RSILON  )) ALLOCATE (X1_ (1)%RSILON     (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%RINDX   )) ALLOCATE (X1_ (1)%RINDX      (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%RINDY   )) ALLOCATE (X1_ (1)%RINDY      (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%RATATH  )) ALLOCATE (X1_ (1)%RATATH     (NBLK*NLON))
IF (ASSOCIATED (X1 (1)%RATATX  )) ALLOCATE (X1_ (1)%RATATX     (NBLK*NLON))

DO JBLK = 1, NBLK
  DO JLON = 1, SIZE (X1(JBLK)%RCOLON, 1)
    IF (ASSOCIATED (X1_ (1)%RCOLON  )) X1_ (1)%RCOLON     ((JBLK-1)*NLON+JLON) = X1 (JBLK)%RCOLON   (JLON)
    IF (ASSOCIATED (X1_ (1)%RSILON  )) X1_ (1)%RSILON     ((JBLK-1)*NLON+JLON) = X1 (JBLK)%RSILON   (JLON)
    IF (ASSOCIATED (X1_ (1)%RINDX   )) X1_ (1)%RINDX      ((JBLK-1)*NLON+JLON) = X1 (JBLK)%RINDX    (JLON)
    IF (ASSOCIATED (X1_ (1)%RINDY   )) X1_ (1)%RINDY      ((JBLK-1)*NLON+JLON) = X1 (JBLK)%RINDY    (JLON)
    IF (ASSOCIATED (X1_ (1)%RATATH  )) X1_ (1)%RATATH     ((JBLK-1)*NLON+JLON) = X1 (JBLK)%RATATH   (JLON)
    IF (ASSOCIATED (X1_ (1)%RATATX  )) X1_ (1)%RATATX     ((JBLK-1)*NLON+JLON) = X1 (JBLK)%RATATX   (JLON)
  ENDDO
ENDDO

DO JBLK = 1, NBLK
 IF (ASSOCIATED (X1 (JBLK)%RCOLON )) DEALLOCATE (X1 (JBLK)%RCOLON )
 IF (ASSOCIATED (X1 (JBLK)%RSILON )) DEALLOCATE (X1 (JBLK)%RSILON )
 IF (ASSOCIATED (X1 (JBLK)%RINDX  )) DEALLOCATE (X1 (JBLK)%RINDX  )
 IF (ASSOCIATED (X1 (JBLK)%RINDY  )) DEALLOCATE (X1 (JBLK)%RINDY  )
 IF (ASSOCIATED (X1 (JBLK)%RATATH )) DEALLOCATE (X1 (JBLK)%RATATH )
 IF (ASSOCIATED (X1 (JBLK)%RATATX )) DEALLOCATE (X1 (JBLK)%RATATX )
ENDDO

DEALLOCATE (X1)

X1 => X1_

END SUBROUTINE

SUBROUTINE CPRS3 (X3, X3_, LDH2D)

REAL (KIND=JPRB) :: X3 (:,:,:,:), X3_ (:,:,:)
LOGICAL :: LDH2D

INTEGER :: JLON, JBLK, NLON, NBLK, I, NI, J, NJ

NLON = SIZE (X3, 1)
NI   = SIZE (X3, 2)
NJ   = SIZE (X3, 3)
NBLK = SIZE (X3, 4)

IF (LDH2D) THEN
!$acc parallel loop present (X3_) copyin (X3) collapse (4)
DO JBLK = 1, NBLK
  DO I = 1, NI
  DO J = 1, NJ
    DO JLON = 1, NLON
      X3_ ((JBLK-1)*NLON+JLON,I,J) = X3 (JLON, I, J, JBLK)
    ENDDO
  ENDDO
  ENDDO
ENDDO
!$acc end parallel loop
ELSE
!$acc parallel loop present (X3_) copyout (X3) collapse (4)
DO JBLK = 1, NBLK
  DO I = 1, NI
  DO J = 1, NJ
    DO JLON = 1, NLON
      X3 (JLON, I, J, JBLK) = X3_ ((JBLK-1)*NLON+JLON,I,J) 
    ENDDO
  ENDDO
  ENDDO
ENDDO
!$acc end parallel loop
ENDIF

END SUBROUTINE

SUBROUTINE CPRS2 (X2, X2_, LDH2D)

REAL (KIND=JPRB) :: X2 (:,:,:), X2_ (:,:)
LOGICAL :: LDH2D

INTEGER :: JLON, JBLK, NLON, NBLK, I, NI

NLON = SIZE (X2, 1)
NI   = SIZE (X2, 2)
NBLK = SIZE (X2, 3)

IF (LDH2D) THEN
!$acc parallel loop present (X2_) copyin (X2) collapse (3)
DO JBLK = 1, NBLK
  DO I = 1, NI
    DO JLON = 1, NLON
      X2_ ((JBLK-1)*NLON+JLON,I) = X2 (JLON, I, JBLK)
    ENDDO
  ENDDO
ENDDO
!$acc end parallel loop
ELSE
!$acc parallel loop present (X2_) copyout (X2) collapse (3)
DO JBLK = 1, NBLK
  DO I = 1, NI
    DO JLON = 1, NLON
      X2 (JLON, I, JBLK) = X2_ ((JBLK-1)*NLON+JLON,I) 
    ENDDO
  ENDDO
ENDDO
!$acc end parallel loop
ENDIF

END SUBROUTINE

SUBROUTINE CPRSI1 (X1, X1_, LDH2D)

INTEGER (KIND=JPIM) :: X1 (:,:), X1_ (:)
LOGICAL :: LDH2D

INTEGER :: JLON, JBLK, NLON, NBLK

NLON = SIZE (X1, 1)
NBLK = SIZE (X1, 2)

IF (LDH2D) THEN
!$acc parallel loop present (X1_) copyin (X1) collapse (2)
DO JBLK = 1, NBLK
  DO JLON = 1, NLON
    X1_ ((JBLK-1)*NLON+JLON) = X1 (JLON, JBLK)
  ENDDO
ENDDO
!$acc end parallel loop
ELSE
!$acc parallel loop present (X1_) copyout (X1) collapse (2)
DO JBLK = 1, NBLK
  DO JLON = 1, NLON
    X1 (JLON, JBLK) = X1_ ((JBLK-1)*NLON+JLON) 
  ENDDO
ENDDO
!$acc end parallel loop
ENDIF

END SUBROUTINE

SUBROUTINE CPRS1 (X1, X1_, LDH2D)

REAL (KIND=JPRB) :: X1 (:,:), X1_ (:)
LOGICAL :: LDH2D

INTEGER :: JLON, JBLK, NLON, NBLK

NLON = SIZE (X1, 1)
NBLK = SIZE (X1, 2)

IF (LDH2D) THEN
!$acc parallel loop present (X1_) copyin (X1) collapse (2)
DO JBLK = 1, NBLK
  DO JLON = 1, NLON
    X1_ ((JBLK-1)*NLON+JLON) = X1 (JLON, JBLK)
  ENDDO
ENDDO
!$acc end parallel loop
ELSE
!$acc parallel loop present (X1_) copyout (X1) collapse (2)
DO JBLK = 1, NBLK
  DO JLON = 1, NLON
    X1 (JLON, JBLK) = X1_ ((JBLK-1)*NLON+JLON) 
  ENDDO
ENDDO
!$acc end parallel loop
ENDIF

END SUBROUTINE

SUBROUTINE REALOX1 (X1, X1_)
REAL (KIND=JPRB), POINTER :: X1 (:,:), X1_ (:)
ALLOCATE (X1_ (SIZE (X1, 1) * SIZE (X1, 2)))
END SUBROUTINE

SUBROUTINE REALOI1 (I1, I1_)
INTEGER (KIND=JPIM), POINTER :: I1 (:,:), I1_ (:)
ALLOCATE (I1_ (SIZE (I1, 1) * SIZE (I1, 2)))
END SUBROUTINE

SUBROUTINE REALOX2 (X2, X2_)
REAL (KIND=JPRB), POINTER :: X2 (:,:,:), X2_ (:,:)
ALLOCATE (X2_ (SIZE (X2, 1) * SIZE (X2, 3), SIZE (X2, 2)))
END SUBROUTINE

SUBROUTINE REALOX3 (X3, X3_)
REAL (KIND=JPRB), POINTER :: X3 (:,:,:,:), X3_ (:,:,:)
ALLOCATE (X3_ (SIZE (X3, 1) * SIZE (X3, 4), SIZE (X3, 2), SIZE (X3, 3)))
END SUBROUTINE

SUBROUTINE REALOI3 (I3, I3_)
REAL (KIND=JPRB), POINTER :: I3 (:,:,:,:), I3_ (:,:,:)
ALLOCATE (I3_ (SIZE (I3, 1) * SIZE (I3, 4), SIZE (I3, 2), SIZE (I3, 3)))
END SUBROUTINE

END

