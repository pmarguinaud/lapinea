MODULE REDUCTION

USE PARKIND1, ONLY : JPRB, JPIM

IMPLICIT NONE

INTERFACE REDUCE
  MODULE PROCEDURE REDUCEK1, REDUCEP2
END INTERFACE

INTERFACE GETLOC
  MODULE PROCEDURE GETLOCP2
END INTERFACE

INTEGER (KIND=JPIM), PARAMETER :: IREDUCTION_MIN = 0, IREDUCTION_MAX = 1, IREDUCTION_SUM = 2
INTEGER (KIND=JPIM), PARAMETER :: IREDUCTION_NONE = 0, IREDUCTION_POW2 = 1

PRIVATE

PUBLIC :: REDUCE
PUBLIC :: IREDUCTION_MIN, IREDUCTION_MAX
PUBLIC :: IREDUCTION_NONE, IREDUCTION_POW2, IREDUCTION_SUM
PUBLIC :: GETLOC

#include "abor1.intfb.h"

CONTAINS

SUBROUTINE GETLOCP2 (P2, PR, KLOC1, KLOC2, KFUNC)

REAL (KIND=JPRB)   , INTENT (IN)  :: P2 (:,:)
REAL (KIND=JPRB)   , INTENT (IN)  :: PR
INTEGER (KIND=JPIM), INTENT (OUT) :: KLOC1
INTEGER (KIND=JPIM), INTENT (OUT) :: KLOC2
INTEGER (KIND=JPIM), INTENT (IN)  :: KFUNC

INTEGER (KIND=JPIM) :: I1, I2, ILOC

KLOC1 = HUGE (KLOC1)
KLOC2 = HUGE (KLOC2)

ILOC = 0

!$acc parallel loop present (P2) copy (ILOC)
DO I2 = 1, SIZE (P2, 2)
  DO I1 = 1, SIZE (P2, 1)
    SELECT CASE (KFUNC)
      CASE (IREDUCTION_NONE)
        IF (PR == P2 (I1, I2)) THEN
!#acc atomic write
          ILOC = I1 + I2 * SIZE (P2, 1)
        ENDIF
      CASE (IREDUCTION_POW2)
        IF (PR == P2 (I1, I2) * P2 (I1, I2)) THEN
!#acc atomic write
          ILOC = I1-1 + (I2-1) * SIZE (P2, 1)
        ENDIF
    END SELECT
  ENDDO
ENDDO
!$acc end parallel loop

KLOC1 = 1 + MODULO (ILOC, SIZE (P2, 1))
KLOC2 = 1 + ILOC / SIZE (P2, 1)

END SUBROUTINE

SUBROUTINE REDUCEK1 (K1, KR, KTYPE, KFUNC)

INTEGER (KIND=JPIM), INTENT (IN)  :: K1 (:)
INTEGER (KIND=JPIM), INTENT (OUT) :: KR
INTEGER (KIND=JPIM), INTENT (IN)  :: KTYPE, KFUNC
INTEGER (KIND=JPIM) :: I1

IF (KTYPE /= IREDUCTION_SUM ) GOTO 999
IF (KFUNC /= IREDUCTION_NONE) GOTO 999

#ifdef _OPENACC

KR = 0

!$acc parallel loop copy (KR) present (K1)
DO I1 = 1, SIZE (K1, 1)
  KR = KR + K1 (I1)
ENDDO

#else

KR = SUM (K1)

#endif

RETURN

999 CONTINUE

CALL ABOR1 ('REDUCTION NOT IMPLEMENTED')

END SUBROUTINE

SUBROUTINE REDUCEP2 (P2, PR, KTYPE, KFUNC)

REAL (KIND=JPRB)   , INTENT (IN)  :: P2 (:,:)
REAL (KIND=JPRB)   , INTENT (OUT) :: PR
INTEGER (KIND=JPIM), INTENT (IN)  :: KTYPE, KFUNC
INTEGER (KIND=JPIM) :: I1, I2

IF (KTYPE /= IREDUCTION_MIN .AND. &
    KTYPE /= IREDUCTION_MAX ) GOTO 999
IF (KFUNC /= IREDUCTION_NONE .AND. &
    KFUNC /= IREDUCTION_POW2) GOTO 999

#ifdef _OPENACC

SELECT CASE (KTYPE)
  CASE (IREDUCTION_MIN)
!$acc parallel loop collapse (2) reduction (min: PR) present (P2)
    DO I2 = 1, SIZE (P2, 2)
      DO I1 = 1, SIZE (P2, 1)
        SELECT CASE (KFUNC)
          CASE (IREDUCTION_NONE)
            PR = P2 (I1, I2)
          CASE (IREDUCTION_POW2)
            PR = P2 (I1, I2) * P2 (I1, I2)
        END SELECT
      ENDDO
    ENDDO
  CASE (IREDUCTION_MAX)
!$acc parallel loop collapse (2) reduction (max: PR) present (P2)
    DO I2 = 1, SIZE (P2, 2)
      DO I1 = 1, SIZE (P2, 1)
        SELECT CASE (KFUNC)
          CASE (IREDUCTION_NONE)
            PR = P2 (I1, I2)
          CASE (IREDUCTION_POW2)
            PR = P2 (I1, I2) * P2 (I1, I2)
        END SELECT
      ENDDO
    ENDDO
END SELECT

#else

SELECT CASE (KTYPE)
  CASE (IREDUCTION_MIN)
    SELECT CASE (KFUNC)
      CASE (IREDUCTION_NONE)
        PR = MINVAL (P2)
      CASE (IREDUCTION_POW2)
        PR = MINVAL (P2 * P2)
    END SELECT 
  CASE (IREDUCTION_MAX)
    SELECT CASE (KFUNC)
      CASE (IREDUCTION_NONE)
        PR = MAXVAL (P2)
      CASE (IREDUCTION_POW2)
        PR = MAXVAL (P2 * P2)
    END SELECT 
END SELECT

#endif

RETURN

999 CONTINUE

CALL ABOR1 ('REDUCTION NOT IMPLEMENTED')

END SUBROUTINE


END MODULE
